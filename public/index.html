<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ¿åèŠå¤©å®¤</title>
    <style>
        body { font-family: sans-serif; max-width: 980px; margin: 20px auto; padding: 0 10px; display: flex; gap: 20px; }
        #main { flex: 3; }
        #sidebar { flex: 1; border-left: 1px solid #ddd; padding-left: 20px; }
        #chat { height: 450px; border: 1px solid #ccc; overflow-y: scroll; padding: 10px; margin-bottom: 10px; background: #f9f9f9; display: flex; flex-direction: column; }
        .msg { margin-bottom: 10px; max-width: 82%; padding: 8px 12px; border-radius: 15px; position: relative; }
        .system { align-self: center; color: #888; font-style: italic; font-size: 0.9em; background: none; text-align: center; }
        .other { align-self: flex-start; background: #fff; border: 1px solid #ddd; }
        .me { align-self: flex-end; background: #dcf8c6; text-align: right; }
        .user-name { font-size: 0.7em; color: #666; margin-bottom: 2px; }
        .time-label { font-size: 0.68em; color: #777; margin-top: 4px; }
        form { display: flex; margin-bottom: 8px; gap: 8px; flex-wrap: wrap; position: relative; }
        input { flex: 1; padding: 10px; }
        button { padding: 10px; }
        #toolbar { display: flex; gap: 8px; margin-bottom: 10px; align-items: center; flex-wrap: wrap; }
        #nickname { max-width: 200px; }
        #room-key { max-width: 260px; }
        #emoji-panel, #gif-panel { display: flex; gap: 6px; flex-wrap: wrap; }
        #gif-toolbar { display: flex; gap: 8px; margin-bottom: 8px; }
        #gif-search { flex: 1; min-width: 160px; }
        .emoji-btn, .gif-btn { border: 1px solid #ddd; border-radius: 8px; background: #fff; padding: 6px 8px; cursor: pointer; }
        .emoji-btn:hover, .gif-btn:hover { background: #f0f0f0; }
        .gif-btn { width: 72px; height: 72px; padding: 0; overflow: hidden; }
        .gif-btn img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .msg-gif { max-width: 220px; border-radius: 10px; margin-top: 4px; }
        #user-list { font-size: 0.9em; line-height: 1.6; }
        .hint { color: #666; font-size: 0.82em; margin-bottom: 8px; }
        .security-panel { margin-bottom: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background: #fcfcfc; }
        .security-title { margin: 0 0 4px; font-size: 0.95em; font-weight: 700; }
        .security-state { font-size: 0.85em; margin-bottom: 4px; }
        .security-state.warn { color: #b56a00; }
        .security-state.safe { color: #267a2f; }
        .security-note { color: #555; font-size: 0.8em; line-height: 1.5; }
        #file-input { display: none; }
        .file-meta { font-size: 12px; color: #444; margin-bottom: 6px; }
        #file-preview { border: 1px dashed #bbb; border-radius: 8px; padding: 8px; margin-bottom: 8px; background: #fff; }
        #file-preview.hidden { display: none; }
        .attachment-wrap { margin-top: 6px; text-align: left; }
        .attachment-image { max-width: 240px; max-height: 180px; border-radius: 8px; display: block; }
        .attachment-link { font-size: 0.85em; display: inline-block; margin-top: 4px; }
        .attachment-pdf { width: 100%; max-width: 320px; height: 220px; border: 1px solid #ccc; border-radius: 8px; }
        .msg-actions { margin-top: 6px; display: flex; justify-content: flex-end; }
        .tiny-btn { font-size: 12px; padding: 3px 6px; }
        .deleted-note { color: #888; font-style: italic; }
        .msg-delete-btn { opacity: 0.35; border: none; background: transparent; cursor: pointer; padding: 2px 4px; font-size: 13px; }
        .msg-delete-btn:hover { opacity: 0.85; }
        .reply-chip { display: inline-flex; align-items: center; gap: 6px; background: #eef4ff; border: 1px solid #cfdcff; border-radius: 8px; padding: 4px 8px; margin-bottom: 6px; font-size: 12px; }
        .reply-chip button { padding: 2px 6px; font-size: 11px; }
        .reply-box { border-left: 3px solid #98b6ff; background: #f5f8ff; border-radius: 6px; padding: 4px 8px; margin-bottom: 6px; font-size: 12px; text-align: left; }
        .reply-meta { color: #4b66a8; font-weight: 600; margin-bottom: 2px; }
        .link-preview { margin-top: 6px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: #fff; text-align: left; max-width: 360px; }
        .link-preview img { width: 100%; max-height: 140px; object-fit: cover; display: block; }
        .link-preview-body { padding: 8px; }
        .link-preview-title { font-size: 13px; font-weight: 700; color: #223; margin-bottom: 4px; }
        .link-preview-desc { font-size: 12px; color: #555; }
        .mention { background: #ffef9f; border-radius: 4px; padding: 0 2px; }
        .hidden { display: none !important; }
        .picker-pop { position: absolute; bottom: calc(100% + 8px); left: 0; width: min(480px, 90vw); background: #fff; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12); padding: 10px; z-index: 40; }
        .picker-pop.hidden { display: none !important; }
        #emoji-pop { max-width: 300px; }
        #gif-pop { max-width: 520px; }
        #gif-panel { margin-top: 8px; max-height: 240px; overflow: auto; }
        .icon-btn { min-width: 44px; padding: 8px 10px; }
        .pdf-actions { margin-top: 6px; display: flex; gap: 6px; }
        #pdf-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.72); display: flex; align-items: center; justify-content: center; z-index: 100; }
        #pdf-modal.hidden { display: none; }
        .pdf-modal-content { width: min(95vw, 1100px); height: min(92vh, 900px); background: #fff; border-radius: 10px; display: flex; flex-direction: column; overflow: hidden; }
        .pdf-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; border-bottom: 1px solid #ddd; }
        #pdf-modal-iframe { border: none; width: 100%; flex: 1; }
    </style>
</head>
<body>
    <div id="main">
        <h2>æ¥µç°¡åŒ¿åèŠå¤©</h2>
        <div id="toolbar">
            <input type="text" id="nickname" maxlength="20" placeholder="ä¿®æ”¹æš±ç¨±" />
            <button type="button" id="rename-btn">æ›´æ–°æš±ç¨±</button>
            <input type="password" id="room-key" placeholder="å¯é¸ï¼šè¼¸å…¥å¯†èªå•Ÿç”¨ç°¡æ˜“åŠ å¯†" autocomplete="off" />
        </div>
        <div class="hint">è¼¸å…¥ç›¸åŒå¯†èªçš„ä½¿ç”¨è€…å¯è§£è®€è¨Šæ¯ï¼›æœªè¼¸å…¥è€…åªæœƒçœ‹åˆ°äº‚ç¢¼ã€‚</div>
        <div id="chat"></div>
        <form id="form">
            <div id="emoji-pop" class="picker-pop hidden">
                <div class="hint">Emoji</div>
                <div id="emoji-panel"></div>
            </div>
            <div id="gif-pop" class="picker-pop hidden">
                <div class="hint">GIF å¿«é¸ï¼ˆå…§å»º + å¤–éƒ¨æœå°‹ï¼‰</div>
                <div id="gif-toolbar">
                    <input type="text" id="gif-search" placeholder="è¼¸å…¥é—œéµå­—æœå°‹ GIF..." autocomplete="off" />
                    <button type="button" id="gif-search-btn">æœå°‹</button>
                    <button type="button" id="gif-refresh-btn">æ›ä¸€æ‰¹</button>
                </div>
                <div id="gif-panel"></div>
            </div>
            <div id="reply-chip" class="reply-chip hidden"></div>
            <button type="button" id="emoji-toggle" class="icon-btn" title="Emoji">ğŸ˜€</button>
            <button type="button" id="gif-toggle" class="icon-btn" title="GIF">GIF</button>
            <input type="text" id="msg" placeholder="è¼¸å…¥è¨Šæ¯..." autocomplete="off" />
            <button type="button" id="attach-btn">ä¸Šå‚³æª”æ¡ˆ</button>
            <button>é€å‡º</button>
        </form>
        <input id="file-input" type="file" accept="image/*,application/pdf,.txt,.md,.json" />
        <div id="file-preview" class="hidden"></div>
    </div>
    <div id="sidebar">
        <div class="security-panel">
            <p class="security-title">ç¶²è·¯ç›£æ§å¯è¦‹æ€§</p>
            <div id="security-state" class="security-state"></div>
            <div id="security-note" class="security-note"></div>
        </div>
        <h4>åœ¨ç·šåå–®</h4>
        <div id="user-list">è¼‰å…¥ä¸­...</div>
    </div>

    <div id="pdf-modal" class="hidden">
        <div class="pdf-modal-content">
            <div class="pdf-modal-header">
                <strong id="pdf-modal-title">PDF é è¦½</strong>
                <button type="button" id="pdf-modal-close">é—œé–‰</button>
            </div>
            <iframe id="pdf-modal-iframe" title="PDF å…¨è¢å¹•é è¦½"></iframe>
        </div>
    </div>

    <script>
        const defaultTitle = 'åŒ¿åèŠå¤©å®¤';
        let unreadCount = 0;
        let titleTicker = null;

        let userId = localStorage.getItem('chat_userId') || 'u_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('chat_userId', userId);

        let myNickname = localStorage.getItem('chat_nickname');
        if (!myNickname) {
            myNickname = prompt('è«‹è¼¸å…¥æ‚¨çš„æš±ç¨±:', 'åŒ¿åè€…' + Math.floor(Math.random() * 100)) || 'åŒ¿åè€…';
            localStorage.setItem('chat_nickname', myNickname);
        }

        const emojis = ['ğŸ˜€', 'ğŸ˜‚', 'ğŸ˜', 'ğŸ¥³', 'ğŸ‘', 'ğŸ™', 'â¤ï¸', 'ğŸ”¥', 'ğŸ˜­', 'ğŸ˜'];
        const gifPageSize = 8;
        let currentGifKeyword = '';
        let gifRefreshSeed = 0;

        const chatDiv = document.getElementById('chat');
        const userListDiv = document.getElementById('user-list');
        const nicknameInput = document.getElementById('nickname');
        const msgInput = document.getElementById('msg');
        const roomKeyInput = document.getElementById('room-key');
        const emojiPanel = document.getElementById('emoji-panel');
        const gifPanel = document.getElementById('gif-panel');
        const gifSearchInput = document.getElementById('gif-search');
        const gifSearchBtn = document.getElementById('gif-search-btn');
        const gifRefreshBtn = document.getElementById('gif-refresh-btn');
        const emojiPop = document.getElementById('emoji-pop');
        const gifPop = document.getElementById('gif-pop');
        const emojiToggle = document.getElementById('emoji-toggle');
        const gifToggle = document.getElementById('gif-toggle');
        const securityState = document.getElementById('security-state');
        const securityNote = document.getElementById('security-note');
        const attachBtn = document.getElementById('attach-btn');
        const fileInput = document.getElementById('file-input');
        const filePreview = document.getElementById('file-preview');
        const replyChip = document.getElementById('reply-chip');
        const pdfModal = document.getElementById('pdf-modal');
        const pdfModalTitle = document.getElementById('pdf-modal-title');
        const pdfModalIframe = document.getElementById('pdf-modal-iframe');
        const pdfModalClose = document.getElementById('pdf-modal-close');

        nicknameInput.value = myNickname;
        const myMessageElements = new Map();
        const messageNodeMap = new Map();
        const readSent = new Set();
        let pendingAttachment = null;
        let replyingTo = null;
        let onlineUsers = [];

        const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', hour12: false });

        function formatLocalTime(iso) {
            if (!iso) return '';
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return '';
            return timeFormatter.format(dt);
        }

        function xorCrypt(text, key) {
            let out = '';
            for (let i = 0; i < text.length; i += 1) out += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
            return out;
        }

        function encodeMessage(text, key) {
            if (!key) return { text, encrypted: false };
            const encrypted = xorCrypt(unescape(encodeURIComponent(text)), key);
            return { text: btoa(encrypted), encrypted: true };
        }

        function decodeMessage(text, key) {
            if (!key) return '[åŠ å¯†è¨Šæ¯ï¼šè«‹è¼¸å…¥å¯†èªè§£å¯†]';
            try {
                const raw = atob(text);
                const decrypted = xorCrypt(raw, key);
                return decodeURIComponent(escape(decrypted));
            } catch {
                return '[ç„¡æ³•è§£å¯†è¨Šæ¯]';
            }
        }

        function updateSecurityStatus() {
            const hasKey = Boolean(roomKeyInput.value);
            const isHttps = window.location.protocol === 'https:';

            securityState.className = 'security-state warn';
            if (isHttps && hasKey) {
                securityState.className = 'security-state safe';
                securityState.textContent = 'ç›®å‰é¢¨éšªè¼ƒä½ï¼šå‚³è¼¸å±¤ + æ‡‰ç”¨å±¤çš†æœ‰ä¿è­·ã€‚';
                securityNote.textContent = 'è‹¥å–®ä½æœ‰ç¶²ç®¡ç›£çœ‹æµé‡ï¼Œé€šå¸¸åªèƒ½çœ‹åˆ°ä½ é€£åˆ°æœ¬ç«™ã€æµé‡å¤§å°èˆ‡æ™‚é–“ï¼›çœ‹ä¸åˆ°èŠå¤©æ˜æ–‡å…§å®¹ã€‚';
            } else if (!isHttps && !hasKey) {
                securityState.textContent = 'é«˜é¢¨éšªï¼šæœªä½¿ç”¨ HTTPSï¼Œä¸”æœªå•Ÿç”¨å¯†èªã€‚';
                securityNote.textContent = 'ç¶²ç®¡å¯èƒ½ç›´æ¥çœ‹åˆ°è¨Šæ¯å…§å®¹ï¼ˆæ˜æ–‡ï¼‰ã€‚å»ºè­°æ”¹ç”¨ HTTPSï¼Œä¸¦è¼¸å…¥èŠå¤©å®¤å¯†èªã€‚';
            } else if (!isHttps) {
                securityState.textContent = 'ä¸­é«˜é¢¨éšªï¼šå·²ä½¿ç”¨å¯†èªï¼Œä½†é€£ç·šä¸æ˜¯ HTTPSã€‚';
                securityNote.textContent = 'ç¶²ç®¡è¼ƒé›£ç›´æ¥è®€æ‡‚å…§å®¹ï¼Œä½†ä»å¯æ””æˆªè³‡æ–™ä¸¦è§€å¯Ÿå¤§é‡ä¸­ç¹¼è³‡è¨Šã€‚å»ºè­°å„ªå…ˆæ”¹ç”¨ HTTPSã€‚';
            } else {
                securityState.textContent = 'ä¸­é¢¨éšªï¼šHTTPS å·²å•Ÿç”¨ï¼Œä½†ç›®å‰æœªä½¿ç”¨å¯†èªã€‚';
                securityNote.textContent = 'ç¶²ç®¡é€šå¸¸çœ‹ä¸åˆ°è¨Šæ¯å…§å®¹ï¼Œä½†æœå‹™ç«¯ä»å¯çœ‹è¦‹æ˜æ–‡ï¼›è‹¥è¦é¡å¤–é˜²è­·å¯å•Ÿç”¨å¯†èªã€‚';
            }
        }

        function setUnreadState() {
            if (document.hidden && unreadCount > 0) {
                if (titleTicker) return;
                let flip = false;
                titleTicker = setInterval(() => {
                    document.title = flip ? `(${unreadCount}) æ–°è¨Šæ¯ï¼` : `${defaultTitle}`;
                    flip = !flip;
                }, 800);
            } else {
                if (titleTicker) clearInterval(titleTicker);
                titleTicker = null;
                document.title = defaultTitle;
            }
        }

        function clearUnread() {
            unreadCount = 0;
            setUnreadState();
        }

        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) clearUnread();
            else setUnreadState();
        });

        function openPdfModal(dataUrl, title) {
            pdfModalTitle.textContent = title || 'PDF é è¦½';
            pdfModalIframe.src = dataUrl;
            pdfModal.classList.remove('hidden');
        }

        function closePdfModal() {
            pdfModal.classList.add('hidden');
            pdfModalIframe.src = '';
        }

        
        function buildReplyChip() {
            if (!replyingTo) {
                replyChip.classList.add('hidden');
                replyChip.innerHTML = '';
                return;
            }
            replyChip.classList.remove('hidden');
            replyChip.innerHTML = `<span>å›è¦† <strong>${replyingTo.user}</strong>: ${replyingTo.text}</span><button type="button" id="clear-reply">å–æ¶ˆ</button>`;
            document.getElementById('clear-reply').onclick = () => {
                replyingTo = null;
                buildReplyChip();
            };
        }

        function getUrls(text) {
            return (text.match(/https?:\/\/[^\s]+/g) || []).slice(0, 2);
        }

        const linkPreviewCache = new Map();
        async function fetchLinkPreview(oneUrl) {
            if (!oneUrl) return null;
            if (linkPreviewCache.has(oneUrl)) return linkPreviewCache.get(oneUrl);
            try {
                const resp = await fetch(`/link-preview?url=${encodeURIComponent(oneUrl)}`);
                const body = await resp.json();
                linkPreviewCache.set(oneUrl, body);
                return body;
            } catch {
                return null;
            }
        }

        function renderTextWithLinks(text, currentUserName) {
            const container = document.createElement('div');
            const parts = (text || '').split(/(https?:\/\/[^\s]+)/g);
            const mentionToken = `@${currentUserName}`;
            parts.forEach(part => {
                if (!part) return;
                if (/^https?:\/\//i.test(part)) {
                    const a = document.createElement('a');
                    a.href = part;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = part;
                    container.appendChild(a);
                    return;
                }

                if (!mentionToken || !part.includes(mentionToken)) {
                    container.appendChild(document.createTextNode(part));
                } else {
                    part.split(mentionToken).forEach((segment, idx, arr) => {
                        if (segment) container.appendChild(document.createTextNode(segment));
                        if (idx < arr.length - 1) {
                            const m = document.createElement('span');
                            m.className = 'mention';
                            m.textContent = mentionToken;
                            container.appendChild(m);
                        }
                    });
                }
            });
            return container;
        }

        function renderAttachment(attachment) {
            if (!attachment) return null;

            const wrap = document.createElement('div');
            wrap.className = 'attachment-wrap';

            if ((attachment.type || '').startsWith('image/')) {
                const img = document.createElement('img');
                img.className = 'attachment-image';
                img.src = attachment.dataUrl;
                img.alt = attachment.name || 'attachment image';
                wrap.appendChild(img);
            } else if ((attachment.type || '').includes('pdf')) {
                const iframe = document.createElement('iframe');
                iframe.className = 'attachment-pdf';
                iframe.src = attachment.dataUrl;
                iframe.title = attachment.name || 'PDF';
                wrap.appendChild(iframe);

                const actions = document.createElement('div');
                actions.className = 'pdf-actions';
                const fullscreenBtn = document.createElement('button');
                fullscreenBtn.type = 'button';
                fullscreenBtn.className = 'tiny-btn';
                fullscreenBtn.textContent = 'å…¨è¢å¹•é è¦½';
                fullscreenBtn.onclick = () => openPdfModal(attachment.dataUrl, attachment.name || 'PDF é è¦½');
                actions.appendChild(fullscreenBtn);
                wrap.appendChild(actions);
            }

            const link = document.createElement('a');
            link.className = 'attachment-link';
            link.href = attachment.dataUrl;
            link.target = '_blank';
            link.rel = 'noopener';
            link.download = attachment.name || 'attachment';
            link.textContent = `ğŸ“ ${attachment.name || 'æª”æ¡ˆ'} (${Math.round((attachment.size || 0) / 1024)} KB)`;
            wrap.appendChild(link);

            return wrap;
        }

        function renderMessage(data) {
            const el = document.createElement('div');
            const timeText = formatLocalTime(data.createdAt);

            if (data.messageId) {
                el.dataset.messageId = data.messageId;
                messageNodeMap.set(data.messageId, el);
            }

            if (data.type === 'system') {
                el.className = 'msg system';
                el.innerText = data.text;
            } else {
                const isMe = data.userId === userId;
                el.className = `msg ${isMe ? 'me' : 'other'}`;

                if (!isMe) {
                    const nameEl = document.createElement('div');
                    nameEl.className = 'user-name';
                    nameEl.innerText = data.user;
                    el.appendChild(nameEl);
                }

                if (data.messageType === 'gif' && data.gifUrl) {
                    const gifEl = document.createElement('img');
                    gifEl.src = data.gifUrl;
                    gifEl.alt = 'GIF';
                    gifEl.className = 'msg-gif';
                    gifEl.loading = 'lazy';
                    el.appendChild(gifEl);
                } else {
                    if (data.replyTo && data.replyTo.messageId) {
                        const replyBox = document.createElement('div');
                        replyBox.className = 'reply-box';
                        const replyMeta = document.createElement('div');
                        replyMeta.className = 'reply-meta';
                        replyMeta.textContent = `å›è¦† ${data.replyTo.user || 'æŸäºº'}`;
                        const replyText = document.createElement('div');
                        replyText.textContent = data.replyTo.text || '';
                        replyBox.appendChild(replyMeta);
                        replyBox.appendChild(replyText);
                        el.appendChild(replyBox);
                    }

                    if (data.text) {
                        const rawText = data.encrypted ? decodeMessage(data.text, roomKeyInput.value) : data.text;
                        const contentEl = renderTextWithLinks(rawText, myNickname);
                        el.appendChild(contentEl);

                        getUrls(rawText).forEach(async (oneUrl) => {
                            const info = await fetchLinkPreview(oneUrl);
                            if (!info) return;
                            const card = document.createElement('a');
                            card.href = oneUrl;
                            card.target = '_blank';
                            card.rel = 'noopener';
                            card.className = 'link-preview';

                            if (info.image) {
                                const img = document.createElement('img');
                                img.src = info.image;
                                img.alt = 'preview';
                                img.loading = 'lazy';
                                card.appendChild(img);
                            }

                            const body = document.createElement('div');
                            body.className = 'link-preview-body';
                            const title = document.createElement('div');
                            title.className = 'link-preview-title';
                            title.textContent = info.title || oneUrl;
                            const desc = document.createElement('div');
                            desc.className = 'link-preview-desc';
                            desc.textContent = info.description || info.host || '';
                            body.appendChild(title);
                            body.appendChild(desc);
                            card.appendChild(body);

                            el.appendChild(card);
                        });
                    }

                    const attachmentEl = renderAttachment(data.attachment);
                    if (attachmentEl) el.appendChild(attachmentEl);
                }

                if (isMe && data.messageId) {
                    const actions = document.createElement('div');
                    actions.className = 'msg-actions';
                    const delBtn = document.createElement('button');
                    delBtn.type = 'button';
                    delBtn.className = 'msg-delete-btn';
                    delBtn.title = 'æ”¶å›/åˆªé™¤';
                    delBtn.textContent = 'ğŸ—‘';
                    delBtn.onclick = () => {
                        fetch('/message/delete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ userId, messageId: data.messageId })
                        });
                    };
                    actions.appendChild(delBtn);
                    el.appendChild(actions);
                }

                if (data.messageId) {
                    const actions = document.createElement('div');
                    actions.className = 'msg-actions';
                    const replyBtn = document.createElement('button');
                    replyBtn.type = 'button';
                    replyBtn.className = 'msg-delete-btn';
                    replyBtn.title = 'å›è¦†';
                    replyBtn.textContent = 'â†©';
                    replyBtn.onclick = () => {
                        const plain = (data.encrypted ? decodeMessage(data.text || '', roomKeyInput.value) : (data.text || '')).slice(0, 80);
                        replyingTo = { messageId: data.messageId, user: data.user || 'æŸäºº', text: plain || '[é™„ä»¶/GIF]' };
                        buildReplyChip();
                        msgInput.focus();
                    };
                    actions.appendChild(replyBtn);
                    el.appendChild(actions);
                }

                if (data.messageId && !isMe && !readSent.has(data.messageId)) {
                    readSent.add(data.messageId);
                    fetch('/read', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId, messageId: data.messageId })
                    });
                }
            }

            if (timeText) {
                const timeEl = document.createElement('div');
                timeEl.className = 'time-label';
                timeEl.innerText = timeText;
                if (data.userId === userId && data.type !== 'system') {
                    if (data.messageId) myMessageElements.set(data.messageId, timeEl);
                    timeEl.dataset.readCount = '0';
                    timeEl.innerText = `${timeText} Â· å·²è®€ 0`;
                }
                el.appendChild(timeEl);
            }

            chatDiv.appendChild(el);
            chatDiv.scrollTop = chatDiv.scrollHeight;
        }

        function markMessageDeleted(messageId) {
            const node = messageNodeMap.get(messageId);
            if (!node) return;

            const note = document.createElement('div');
            note.className = 'deleted-note';
            note.textContent = 'æ­¤è¨Šæ¯å·²è¢«æ”¶å›ã€‚';

            node.querySelectorAll('.msg-gif,.attachment-wrap,.msg-actions').forEach(n => n.remove());
            const texts = Array.from(node.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE && n.className !== 'time-label' && n.className !== 'user-name');
            texts.forEach(n => n.remove());
            node.appendChild(note);
        }

        function sendHeartbeat() {
            fetch('/heartbeat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId })
            });
        }

        let lastHeartbeatAt = 0;
        function heartbeatOnActivity() {
            const now = Date.now();
            if (now - lastHeartbeatAt < 20000) return;
            lastHeartbeatAt = now;
            sendHeartbeat();
        }

        function closeAllPoppers() {
            emojiPop.classList.add('hidden');
            gifPop.classList.add('hidden');
        }

        emojiToggle.onclick = () => {
            const willOpen = emojiPop.classList.contains('hidden');
            closeAllPoppers();
            if (willOpen) emojiPop.classList.remove('hidden');
        };

        gifToggle.onclick = () => {
            const willOpen = gifPop.classList.contains('hidden');
            closeAllPoppers();
            if (willOpen) gifPop.classList.remove('hidden');
        };

        document.addEventListener('click', (event) => {
            if (event.target.closest('#emoji-pop, #gif-pop, #emoji-toggle, #gif-toggle')) return;
            closeAllPoppers();
        });

        pdfModalClose.onclick = closePdfModal;
        pdfModal.addEventListener('click', (event) => {
            if (event.target === pdfModal) closePdfModal();
        });

        emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'emoji-btn';
            btn.textContent = emoji;
            btn.onclick = () => {
                msgInput.value += emoji;
                msgInput.focus();
                closeAllPoppers();
                heartbeatOnActivity();
            };
            emojiPanel.appendChild(btn);
        });

        function renderGifOptions(items) {
            gifPanel.innerHTML = '';
            if (!items.length) {
                gifPanel.innerHTML = '<div class="hint">æ‰¾ä¸åˆ° GIFï¼Œè«‹æ›å€‹é—œéµå­—è©¦è©¦ã€‚</div>';
                return;
            }

            items.forEach(item => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'gif-btn';
                btn.title = `å‚³é€ GIF: ${item.name}`;
                btn.innerHTML = `<img src="${item.url}" alt="${item.name}" loading="lazy" />`;
                btn.onclick = () => {
                    fetch('/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId, messageType: 'gif', gifUrl: item.url, message: '' })
                    });
                    closeAllPoppers();
                    heartbeatOnActivity();
                };
                gifPanel.appendChild(btn);
            });
        }

        async function loadGifs(keyword = '', refresh = false) {
            const query = keyword.trim();
            currentGifKeyword = query;
            if (refresh) gifRefreshSeed += 1;

            gifSearchBtn.disabled = true;
            gifRefreshBtn.disabled = true;
            try {
                const params = new URLSearchParams({ q: query, refresh: String(gifRefreshSeed), limit: String(gifPageSize) });
                const resp = await fetch(`/gifs?${params.toString()}`);
                const body = await resp.json();
                renderGifOptions(body.items || []);
            } catch {
                gifPanel.innerHTML = '<div class="hint">GIF è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚</div>';
            } finally {
                gifSearchBtn.disabled = false;
                gifRefreshBtn.disabled = false;
            }
        }

        function clearPendingAttachment() {
            pendingAttachment = null;
            fileInput.value = '';
            filePreview.innerHTML = '';
            filePreview.classList.add('hidden');
        }

        function showAttachmentPreview(att) {
            filePreview.innerHTML = '';
            filePreview.classList.remove('hidden');

            const meta = document.createElement('div');
            meta.className = 'file-meta';
            meta.textContent = `æº–å‚™ä¸Šå‚³: ${att.name} (${Math.round(att.size / 1024)} KB)`;
            filePreview.appendChild(meta);

            const visual = renderAttachment(att);
            if (visual) filePreview.appendChild(visual);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'tiny-btn';
            removeBtn.textContent = 'å–æ¶ˆé™„ä»¶';
            removeBtn.onclick = clearPendingAttachment;
            filePreview.appendChild(removeBtn);
        }

        attachBtn.onclick = () => fileInput.click();
        fileInput.onchange = () => {
            const file = fileInput.files && fileInput.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                pendingAttachment = {
                    name: file.name,
                    type: file.type || 'application/octet-stream',
                    size: file.size,
                    dataUrl: String(reader.result || '')
                };
                showAttachmentPreview(pendingAttachment);
            };
            reader.readAsDataURL(file);
        };

        gifSearchBtn.addEventListener('click', () => loadGifs(gifSearchInput.value));
        gifRefreshBtn.addEventListener('click', () => loadGifs(currentGifKeyword, true));
        gifSearchInput.addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                loadGifs(gifSearchInput.value);
            }
        });

        const evtSource = new EventSource(`/events?id=${userId}&name=${encodeURIComponent(myNickname)}`);
        evtSource.onmessage = function(event) {
            const data = JSON.parse(event.data);

            if (data.type === 'userList') {
                onlineUsers = data.users || [];
                userListDiv.innerHTML = onlineUsers.map(u => `<div class="user-item" data-user="${u}">â— ${u}</div>`).join('');
                userListDiv.querySelectorAll('.user-item').forEach(item => {
                    item.onclick = () => {
                        const name = item.dataset.user || '';
                        if (!name) return;
                        const prefix = msgInput.value && !msgInput.value.endsWith(' ') ? ' ' : '';
                        msgInput.value += `${prefix}@${name} `;
                        msgInput.focus();
                    };
                });
                return;
            }

            if (data.type === 'readReceipt') {
                const timeEl = myMessageElements.get(data.messageId);
                if (timeEl) {
                    const timeText = timeEl.innerText.split(' Â· ')[0];
                    timeEl.dataset.readCount = String(data.readCount || 0);
                    timeEl.innerText = `${timeText} Â· å·²è®€ ${data.readCount || 0}`;
                }
                return;
            }

            if (data.type === 'messageDeleted') {
                markMessageDeleted(data.messageId);
                return;
            }

            if (data.type === 'message' && data.userId !== userId && document.hidden) {
                unreadCount += 1;
                setUnreadState();
            }

            renderMessage(data);
        };

        evtSource.onerror = () => {
            renderMessage({ type: 'system', text: 'é€£ç·šå·²ä¸­æ–·ã€‚', createdAt: new Date().toISOString() });
            evtSource.close();
        };

        document.getElementById('rename-btn').onclick = function() {
            const newName = nicknameInput.value.trim().slice(0, 20);
            if (!newName || newName === myNickname) return;

            fetch('/nickname', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nickname: newName, userId: userId })
            }).then(() => {
                myNickname = newName;
                localStorage.setItem('chat_nickname', myNickname);
            });
        };

        nicknameInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('rename-btn').click();
            }
        });

        roomKeyInput.addEventListener('input', updateSecurityStatus);

        document.getElementById('form').onsubmit = function(e) {
            e.preventDefault();
            if (!msgInput.value && !pendingAttachment) return;

            const key = roomKeyInput.value;
            const payload = encodeMessage(msgInput.value, key);

            fetch('/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: payload.text,
                    encrypted: payload.encrypted,
                    messageType: 'text',
                    userId: userId,
                    attachment: pendingAttachment,
                    replyTo: replyingTo
                })
            });

            msgInput.value = '';
            clearPendingAttachment();
            replyingTo = null;
            buildReplyChip();
            heartbeatOnActivity();
        };

        ['mousemove', 'keydown', 'click', 'touchstart'].forEach(eventName => {
            document.addEventListener(eventName, heartbeatOnActivity, { passive: true });
        });
        setInterval(sendHeartbeat, 60000);
        updateSecurityStatus();
        sendHeartbeat();
        loadGifs();
        buildReplyChip();
    </script>
</body>
</html>
